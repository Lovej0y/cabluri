CMS messages exchange
=====================

Authentication and encryption
-----------------------------

<send>
  + [message]     <- <input>
  + [message]     -> signed    with sender's    [private sign.pem]    -> [message.sig]
  + [message.sig] -> encrypted with recipient's [X.509   encrypt.pem] -> [message.out]
  + [message.out] -> <send>

<recv>
  + [message.out] <- <receive>
  + [message.out] -> decrypted with recipient's [private decrypt.pem] -> [message.sig]
  + [message.sig] -> verified  wrt  sender's    [X.509   verify.pem]  -> [message]
  +               -> r-signed  with recipient's [private sign.pem]    -> [receipt.sig]
  + [receipt.sig] -> encrypted with sender's    [X.509   encrypt.pem] -> [receipt.out]
  + [receipt.out] -> <send>

<ack>
  + [receipt.out] <- <receive>
  + [receipt.out] -> decrypted with sender's    [private decrypt.pem] -> [receipt.sig]
  + [receipt.sig] -> verified  wrt  recipient's [X.509   verify.pem]  +  [message.sig]
  + [hash(receipt.sig)] -> <send>


Protocol
--------
  + username is explicitly verified against root CA fingerprint
  + hostname is implicitly verified when fetching files
  + resistant against MITM injections (except MSG substitution with same <msgid>)
  + resistant against temporary MITM resources substitution

  + resistant against fingerprinting if username is unknown
  + vulnerable to DoS (e.g., many MSG requests) if username is known

  + each loop type is mutually exclusive for a given <msgid>
  + all code block are restartable (e.g., after crash)
  + messages are never lost if filesystem is transactional

  + <hostname>/<username>/                         public directory w/o list permission
                  /certs/                          public X.509 certificates
                  /queue/<msgid>                   outgoing message <msgid>
                  /rqueue/<msgid>                  outgoing receipt <msgid>
  + /cables/                                       private directory
                  /queue/<msgid>/                  outgoing message <msgid> work dir
                  /rqueue/<msgid>/                 outgoing receipt <msgid> work dir

  + [MUA]         reads from MUA directory, writes to /cables/queue
  + [service]     writes to /cables/{queue,rqueue}
  + [fetch  loop] fetches from network, writes to /cables/{queue,rqueue}
  + [crypto loop] writes to /cables/{queue,rqueue}, MUA directory
  + [comm   loop] sends to network, writes to /{<username>,cables}/{queue,rqueue}


<send>
  [MUA]
  + generate random 160-bit (40 hex digits) <msgid>
  + prepare /cables/queue/<msgid>/{message,username,hostname}
  + create  /cables/queue/<msgid>/send.req
  + return  OK

  [fetch loop]
  + check   /cables/queue/<msgid>/send.req
  + fetch   <hostname>/<username>/certs/*          -> /cables/queue/<msgid>/
  + rename  /cables/queue/<msgid>/send.req         -> send.rdy

  [crypto loop]
  + check   /cables/queue/<msgid>/send.rdy
  + prepare /cables/queue/<msgid>/message.out
  + rename  /cables/queue/<msgid>/send.rdy         -> send.ok  (success)
  +                                                -> send.req (fail)

  [comm loop]
  + check   /cables/queue/<msgid>/send.ok
  + checkno /cables/queue/<msgid>/ack.ok
  + copy    /cables/queue/<msgid>/message.out -> //<susername>/queue/<msgid> (if not exists)
  + send    "MSG <shostname> <susername> <msgid>" to <hostname>


<recv>
  [service]
  + upon    "MSG <hostname> <username> <msgid>"
  + prepare /cables/rqueue/<msgid>/{username,hostname}
  + create  /cables/rqueue/<msgid>/recv.req

  [fetch loop]
  + check   /cables/rqueue/<msgid>/recv.req
  + checkno /cables/rqueue/<msgid>/recv.{rdy,ok}
  + fetch   <hostname>/<username>/queue/<msgid>    -> /cables/rqueue/<msgid>/
  + fetch   <hostname>/<username>/certs/*          -> /cables/rqueue/<msgid>/
  + rename  /cables/rqueue/<msgid>/recv.req        -> recv.rdy

  [crypto loop]
  + check   /cables/rqueue/<msgid>/recv.rdy
  + prepare /cables/rqueue/<msgid>/{message,receipt.{ack,out}}
  + create  <mua message>                          <- /cables/rqueue/<msgid>/message
  + rename  /cables/rqueue/<msgid>/recv.rdy        -> recv.ok  (success)
  +                                                -> recv.req (fail)

  [comm loop]
  + check   /cables/rqueue/<msgid>/recv.ok
  + copy    /cables/rqueue/<msgid>/receipt.out -> //<rusername>/rqueue/<msgid> (if not exists)
  + send    "RCP <msgid>" to <hostname>


<ack>
  [service]
  + upon    "RCP <msgid>"
  + create  /cables/queue/<msgid>/ack.req

  [fetch loop]
  + check   /cables/queue/<msgid>/ack.req
  + checkno /cables/queue/<msgid>/ack.{rdy,ok}
  + fetch   <hostname>/<username>/rqueue/<msgid>   -> /cables/queue/<msgid>/receipt.out
  + rename  /cables/queue/<msgid>/ack.req          -> ack.rdy

  [crypto loop]
  + check   /cables/queue/<msgid>/ack.rdy
  + prepare /cables/queue/<msgid>/receipt.ack
  + create  <mua acknowledge>
  + rename  /cables/queue/<msgid>/ack.rdy          -> ack.ok  (success)
  +                                                -> ack.req (fail)

  [comm loop]
  + check   /cables/queue/<msgid>/ack.ok
  + remove  //<susername>/queue/<msgid>             (if exists)
  + read    /cables/queue/<msgid>/receipt.ack       (128 hex digits)
  + send    "ACK <msgid> <ackhash>" to <hostname>   (wait for OK)
  + remove  /cables/queue/<msgid>/                  (if exists, atomic)


<fin>
  [service]
  + upon    "ACK <msgid> <ackhash>"
  + check   /cables/rqueue/<msgid>/recv.ok          (if <msgid>/ exists)
  + compare /cables/rqueue/<msgid>/receipt.ack      <-> <ackhash>
  + remove  /cables/rqueue/<msgid>/                 (if exists, atomic)
  + return  OK

  [comm loop]
  + checkno /cables/rqueue/<msgid>/
  + remove  //<rusername>/rqueue/<msgid>            (if exists)
