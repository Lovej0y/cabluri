Message exchange with PFS and repudiability
===========================================

Authentication and encryption
-----------------------------

Permanent keys:
  + public X.509   [ca.pem] (root CA) + username (hash of [ca.pem])
  + public X.509   [verify.pem]                  (issued by root CA)
  + public DH key  [peer.sig]                    (signed, verifiable with [verify.pem])
  + private key    [sign.pem]                    (corresponding to X.509 [verify.pem])
  + private DH key [derive.pem]                  (corresponding to DH [peer.pem])

Ephemeral keys:
  + public DH key  [peereph.sig]                 (signed, verifiable with [verify.pem])
  + private DH key [deriveeph.pem]               (corresponding to DH [peereph.pem])
  + shared         [shared.key]

Key derivation:
  + sender's ephemeral DH key [peereph.pem] or [deriveeph.pem]
  + recipient's static DH key [peer.pem]    or [derive.pem]
  + MAC/MAC2/MAC3 keys are different hashes of the derived [shared.key]
    (ephemeral-static key agreement, http://tools.ietf.org/html/rfc2785)

<send>
  + [message]                                                    <- <input>
  + [peer.sig]      -> verified  with recipient's [verify.pem]   -> [peer.der]
  + [deriveeph.pem] + [peer.der] -> DH key derivation            -> [shared.key]
  + [peereph.der]   -> signed    with sender's    [sign.pem]     -> [peereph.sig]
  + [message]       -> encrypted with shared      [shared.key]   -> [message.enc]
  + [message.enc] + [peereph.sig] + MAC(message)                 -> <send>

<recv>
  + [message.enc] + [peereph.sig] + MAC(message)                 <- <receive>
  + [peereph.sig]   -> verified  with sender's    [verify.pem]   -> [peereph.der]
  + [derive.pem]  + [peereph.der] -> DH key derivation           -> [shared.key]
  + [message.enc]   -> decrypted with shared      [shared.key]   -> [message]
  + [message]       -> verified  with shared      MAC
  + [message]       -> signed    with shared      MAC2           -> MAC2([message])
  + MAC2([message])                                              -> <send>

<ack>
  + MAC2([message])                                              <- <receive>
  + MAC2([message]) -> verified  with shared      MAC2
  + MAC3                                                         -> <send>

<fin>
  + MAC3                                                         <- <receive>
  + MAC3            -> verified  with shared      MAC3


Protocol
--------
  + username is explicitly verified against public key fingerprint
  + hostname is implicitly verified when fetching files
  + perfect forward secrecy and repudiability
  + resistant against MITM injections (except first MSG substitution with same <msgid>)
  + resistant against temporary MITM resources substitution
  + resistant to request replay attacks intended to cause large number of disk writes

  + resistant against fingerprinting if username is unknown
  + vulnerable to DoS (e.g., many MSG requests) if username is known
  + vulnerable to message replay

  + each loop type is mutually exclusive for a given (r)queue/<msgid>
  + all code blocks are restartable (e.g., after crash)
  + messages and confirmations are never lost if /cables filesystem is transactional

  + <hostname>/<username>/                         transient public directory w/o list permission
                  /certs/{ca.pem,verify.pem}       public certificates
                  /certs/peer.sig                  public static peer key
                  /queue/<msgid>                   outgoing message <msgid>
                  /queue/<msgid>.key               outgoing message <msgid>'s ephemeral peer key
                  /request/...                     service interface

  + /cables/                                       private directory
                  /queue/<msgid>/                  outgoing message <msgid> work dir
                  /rqueue/<msgid>/                 incoming message <msgid> work dir

  + [send]        (MUA-invoked script)          writes to /cables/queue
  + [service]     (fast and secure web service) writes to /cables/{queue,rqueue}
  + [crypto loop] writes to /cables/{queue,rqueue}, MUA inbox directory;
                  reads from certs directory
  + [fetch  loop] writes to /cables/{queue,rqueue}; reads from network
  + [comm   loop] writes to /{<username>,cables}/{queue,rqueue}, network;
                  reads username from certs directory


<send>
  [send]
  + generate random 160-bit (40 hex digits) <msgid>
  + prepare /cables/queue/<msgid>/{message{,.hdr},username,{,s}hostname}
  + create  /cables/queue/<msgid>/send.req
  * (atomic via rename from /cables/queue/tmp.<random>/<msgid>/)

  [fetch loop]
  + check   /cables/queue/<msgid>/send.req
  + fetch   <hostname>/<username>/certs/{{ca,verify}.pem,peer.sig} -> /cables/queue/<msgid>/
  + rename  /cables/queue/<msgid>/send.req         -> send.rdy

  [crypto loop]
  + check   /cables/queue/<msgid>/send.rdy
  + prepare /cables/queue/<msgid>/{peereph.sig,message.enc,{send,recv,ack}.mac}
  + rename  /cables/queue/<msgid>/send.rdy         -> send.ok  (success)
  +                                                -> send.req (crypto fail)
  + remove  /cables/queue/<msgid>/{message,{ca,verify}.pem,peer.sig}  (if success)

  [comm loop]
  + check   /cables/queue/<msgid>/send.ok
  + checkno /cables/queue/<msgid>/ack.ok
  + copy    /cables/queue/<msgid>/peereph.sig      -> //<susername>/queue/<msgid>.key (if not exists)
  + copy    /cables/queue/<msgid>/message.enc      -> //<susername>/queue/<msgid>     (atomic, if not exists)
  + read    /cables/queue/<msgid>/send.mac         (128 hex digits)
  + request <hostname>/<username>/request/msg/<msgid>/<sendmac>/<shostname>/<susername> -> send.ans


<recv>
  [service]
  + upon    msg/<msgid>/<sendmac>/<hostname>/<username>
  + checkno /cables/rqueue/<msgid>
  + create  /cables/rqueue/<msgid>.new/            (ok if exists)
  + write   /cables/rqueue/<msgid>.new/{username,hostname,send.mac}
  + create  /cables/rqueue/<msgid>.new/recv.req    (ok if exists)
  + rename  /cables/rqueue/<msgid>.new             -> <msgid>

  [fetch loop]
  + check   /cables/rqueue/<msgid>/recv.req
  + fetch   <hostname>/<username>/queue/<msgid>     -> /cables/rqueue/<msgid>/message.enc
  + fetch   <hostname>/<username>/queue/<msgid>.key -> /cables/rqueue/<msgid>/peereph.sig
  + fetch   <hostname>/<username>/certs/{ca,verify}.pem -> /cables/rqueue/<msgid>/
  + rename  /cables/rqueue/<msgid>/recv.req         -> recv.rdy

  [crypto loop]
  + check   /cables/rqueue/<msgid>/recv.rdy
  + prepare /cables/rqueue/<msgid>/{message{,.hdr},{recv,ack}.mac}
  + verify  /cables/rqueue/<msgid>/send.mac
  + create  <mua message>                          <- /cables/rqueue/<msgid>/message
  + rename  /cables/rqueue/<msgid>/recv.rdy        -> recv.ok  (success)
  +                                                -> recv.req (crypto fail)
  + remove  /cables/rqueue/<msgid>/{message{,.enc},{ca,verify}.pem,peereph.sig,send.mac}  (if success)

  [comm loop]
  + check   /cables/rqueue/<msgid>/recv.ok
  + read    /cables/rqueue/<msgid>/recv.mac        (128 hex digits)
  + request <hostname>/<username>/request/rcp/<msgid>/<recvmac> -> recv.ans


<ack>
  [service]
  + upon    rcp/<msgid>/<recvmac>
  + check   /cables/queue/<msgid>/send.ok
  + compare /cables/queue/<msgid>/recv.mac        <-> <recvmac>
  + create  /cables/queue/<msgid>/ack.req          (atomic, ok if exists)
  + touch   /cables/queue/<msgid>/                 (if ack.req did not exist)

  [crypto loop]
  + check   /cables/queue/<msgid>/ack.req
  + checkno /cables/queue/<msgid>/ack.ok
  + create  <mua acknowledge>
  + rename  /cables/queue/<msgid>/ack.req          -> ack.ok
  + remove  /cables/queue/<msgid>/{message.enc,peereph.sig,{send,recv}.mac}  (if success)

  [comm loop]
  + check   /cables/queue/<msgid>/ack.ok
  + remove  //<susername>/queue/<msgid>{,.key}     (if exists)
  + read    /cables/queue/<msgid>/ack.mac          (128 hex digits)
  + request <hostname>/<username>/request/ack/<msgid>/<ackmac> (wait) -> ack.ans
  + rename  /cables/queue/<msgid>                  -> <msgid>.del
  (if ack is lost due to MITM attack, receiver will keep requesting rcp/<msgid>/<recvmac>)

  -and/or-

  + check   /cables/queue/<msgid>.del/
  + remove  //<susername>/queue/<msgid>{,.key}     (if exists)
  + remove  /cables/queue/<msgid>.del/


<fin>
  [service]
  + upon    ack/<msgid>/<ackmac>
  + check   /cables/rqueue/<msgid>/recv.ok
  + compare /cables/rqueue/<msgid>/ack.mac        <-> <ackmac>
  + rename  /cables/rqueue/<msgid>                 -> <msgid>.del

  [comm loop]
  + check   /cables/rqueue/<msgid>.del/
  + remove  /cables/rqueue/<msgid>.del/


Loop scheduler
--------------

Initialization (for <msgid>s of 40 hex digits):
  + remove /cables/rqueue/<msgid>.new/                (before [service] startup)

Watch list (for <msgid>s of 40 hex digits):
  + /cables/queue/  <msgid>, <msgid>.del              (inotify: moved_to, attrib)
  + /cables/rqueue/ <msgid>, <msgid>.del              (inotify: moved_to)

  + <msgid>:     non-blocking lock attempt
  + <msgid>.del: blocking lock (with timeout)

Retry policies:
  + retry every X min. (+ random component)

Validation: upon reaching max age (from <msgid>/username timestamp):
  (mutually exclusive with all loop types)

  + (queue)  create  <mua message>
                 send.req/rdy:        failed to fetch certificates and encrypt message
                 send.ok + no ack.ok: failed to send message and receive receipt
                 ack.ok:              failed to acknowledge receipt
  + (queue)  rename  /cables/queue/<msgid>  -> <msgid>.del

  + (rqueue) create  <mua message>
                 recv.req/rdy:        failed to fetch and decrypt message
                 recv.ok:             failed to send receipt and receive acknowledgment
  + (rqueue) rename  /cables/rqueue/<msgid> -> <msgid>.del


Message format
--------------

(send)
  + extract all unique To:, Cc:, Bcc: addresses
  + check that all addresses (+ From:) are recognized (e.g., *.onion)
  + remove Bcc: and all X-*: headers
  + reformat Date: as UTC
  + compress with gzip


(recv)
  + uncompress with classic (single-threaded) gzip
  + replace From: header with the verified address (rename old header)
  + add X-Received-Date: header


(ack)
  + extract original From:, To:, Cc:, Bcc:, Subject:, Date:, Message-ID:,
                     In-Reply-To:, References: fields
  + replace Date: header with current date (rename old header)
  + prepend [vfy] to Subject: field contents
  + append body with verification message, including current timestamp
    and verified delivery address
