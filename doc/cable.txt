CMS messages exchange
=====================

Authentication and encryption
-----------------------------

<send>
  + [message]     <- <input>
  + [message]     -> signed    with sender's    [private sign.pem]    -> [message.sig]
  + [message.sig] -> encrypted with recipient's [X.509   encrypt.pem] -> [message.out]
  + [message.out] -> <send>

<recv>
  + [message.out] <- <receive>
  + [message.out] -> decrypted with recipient's [private decrypt.pem] -> [message.sig]
  + [message.sig] -> verified  wrt  sender's    [X.509   verify.pem]  -> [message]
  +               -> r-signed  with recipient's [private sign.pem]    -> [receipt.sig]
  + [receipt.sig] -> encrypted with sender's    [X.509   encrypt.pem] -> [receipt.out]
  + [receipt.out] -> <send>

<ack>
  + [receipt.out] <- <receive>
  + [receipt.out] -> decrypted with sender's    [private decrypt.pem] -> [receipt.sig]
  + [receipt.sig] -> verified  wrt  recipient's [X.509   verify.pem]  +  [message.sig]
  + [hash(receipt.sig)] -> <send>


Protocol
--------
  + username is explicitly verified against root CA fingerprint
  + hostname is implicitly verified when fetching files
  + resistant against MITM injections (except first MSG substitution with same <msgid>)
  + resistant against temporary MITM resources substitution
  + resistant to request replay attacks intended to cause large number of disk writes

  + resistant against fingerprinting if username is unknown
  + vulnerable to DoS (e.g., many MSG requests) if username is known

  + each loop type is mutually exclusive for a given <msgid>
  + all code blocks are restartable (e.g., after crash)
  + messages and receipts are never lost if filesystem is transactional

  + <hostname>/<username>/                         volatile public directory w/o list permission
                  /certs/                          public X.509 certificates
                  /queue/<msgid>                   outgoing message <msgid>
                  /rqueue/<msgid>                  outgoing receipt <msgid>
                  /request/...                     service interface

  + /cables/                                       private directory
                  /queue/<msgid>/                  outgoing message <msgid> work dir
                  /rqueue/<msgid>/                 outgoing receipt <msgid> work dir

  + [send]        reads from MUA directory, writes to /cables/queue
  + [service]     writes to /cables/{queue,rqueue}
  + [crypto loop] writes to /cables/{queue,rqueue}, MUA directory; reads from X.509 directory
  + [fetch  loop] fetches from network, writes to /cables/{queue,rqueue}
  + [comm   loop] sends to network, writes to /{<username>,cables}/{queue,rqueue}


<send>
  [send]
  + generate random 160-bit (40 hex digits) <msgid>
  + prepare /cables/queue/<msgid>/{message{,.hdr},username,{,s}hostname}
  + create  /cables/queue/<msgid>/send.req

  [fetch loop]
  + check   /cables/queue/<msgid>/send.req
  + fetch   <hostname>/<username>/certs/*.pem      -> /cables/queue/<msgid>/*.pem
  + rename  /cables/queue/<msgid>/send.req         -> send.rdy

  [crypto loop]
  + check   /cables/queue/<msgid>/send.rdy
  + prepare /cables/queue/<msgid>/message.out
  + rename  /cables/queue/<msgid>/send.rdy         -> send.ok  (success)
  +                                                -> send.req (crypto fail)
  + remove  /cables/queue/<msgid>/message          (if success)

  [comm loop]
  + check   /cables/queue/<msgid>/send.ok
  + checkno /cables/queue/<msgid>/ack.ok
  + copy    /cables/queue/<msgid>/message.out -> //<susername>/queue/<msgid> (atomic, if not exists)
  + request <hostname>/<username>/request/msg/<msgid>/<shostname>/<susername>


<recv>
  [service]
  + upon    msg/<msgid>/<hostname>/<username>
  + checkno /cables/rqueue/<msgid>
  + create  /cables/rqueue/<msgid>.new/            (ok if exists)
  + write   /cables/rqueue/<msgid>.new/{username,hostname}
  + create  /cables/rqueue/<msgid>.new/recv.req    (ok if exists)
  + rename  /cables/rqueue/<msgid>.new             -> <msgid>

  [fetch loop]
  + check   /cables/rqueue/<msgid>/recv.req
  + checkno /cables/rqueue/<msgid>/recv.{rdy,ok}
  + fetch   <hostname>/<username>/queue/<msgid>    -> /cables/rqueue/<msgid>/message.out
  + fetch   <hostname>/<username>/certs/*.pem      -> /cables/rqueue/<msgid>/*.pem
  + rename  /cables/rqueue/<msgid>/recv.req        -> recv.rdy

  [crypto loop]
  + check   /cables/rqueue/<msgid>/recv.rdy
  + prepare /cables/rqueue/<msgid>/{message,receipt.{ack,out}}
  + create  <mua message>                          <- /cables/rqueue/<msgid>/message
  + rename  /cables/rqueue/<msgid>/recv.rdy        -> recv.ok  (success)
  +                                                -> recv.req (crypto fail)
  + remove  /cables/rqueue/<msgid>/message{,.out}  (if success)

  [comm loop]
  + check   /cables/rqueue/<msgid>/recv.ok
  + copy    /cables/rqueue/<msgid>/receipt.out -> //<rusername>/rqueue/<msgid> (atomic, if not exists)
  + request <hostname>/<username>/request/rcp/<msgid>


<ack>
  [service]
  + upon    rcp/<msgid>
  + check   /cables/queue/<msgid>/send.ok
  + create  /cables/queue/<msgid>/ack.req          (ok if exists)

  [fetch loop]
  + check   /cables/queue/<msgid>/ack.req
  + checkno /cables/queue/<msgid>/ack.{rdy,ok}
  + fetch   <hostname>/<username>/rqueue/<msgid>   -> /cables/queue/<msgid>/receipt.out
  + rename  /cables/queue/<msgid>/ack.req          -> ack.rdy

  [crypto loop]
  + check   /cables/queue/<msgid>/ack.rdy
  + prepare /cables/queue/<msgid>/receipt.ack
  + create  <mua acknowledge>
  + rename  /cables/queue/<msgid>/ack.rdy          -> ack.ok  (success)
  +                                                -> ack.req (crypto fail)
  + remove  /cables/queue/<msgid>/{message.{out,sig},receipt.out}  (if success)

  [comm loop]
  + check   /cables/queue/<msgid>/ack.ok
  + remove  //<susername>/queue/<msgid>            (if exists)
  + read    /cables/queue/<msgid>/receipt.ack      (128 hex digits)
  + request <hostname>/<username>/request/ack/<msgid>/<ackhash> (wait)
  + rename  /cables/queue/<msgid>                  -> <msgid>.trash
  + remove  /cables/queue/<msgid>.trash/           (+ gc before start)
  (if ack is lost due to MITM attack, receiver will keep requesting rcp/<msgid>)


<fin>
  [service]
  + upon    ack/<msgid>/<ackhash>
  + check   /cables/rqueue/<msgid>/recv.ok
  + compare /cables/rqueue/<msgid>/receipt.ack    <-> <ackhash>
  + rename  /cables/rqueue/<msgid>                 -> <msgid>.trash

  [comm loop]
  + check   /cables/rqueue/<msgid>.trash/
  + remove  //<rusername>/rqueue/<msgid>           (if exists)
  + remove  /cables/rqueue/<msgid>.trash/


Message format
--------------

(send)
  + extract all To:, Cc:, Bcc: addresses
  + check that all addresses are recognized (e.g., *.onion)
  + remove Bcc: and all X-*: headers
  + reformat Date: as UTC
  + compress with gzip


(recv)
  + uncompress with classic (single-threaded) gzip
  + replace From: header with the verified address (rename old header)
  + add X-Received-Date: header
