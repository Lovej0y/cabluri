#!/bin/sh -e

# This script ensures at most one running instance for a <msgid>

umask 077
export LC_ALL=C


if [ $# -lt 2  -o  \( queue != "$1"  -a  rqueue != "$1" \) ]; then
    echo "Format: $0 queue|rqueue <msgid>[.del]"
    exit 1
fi


# Helpers
prefix="${0##*/}"
prefix="${0%${prefix}}"
validate="${prefix}"validate
fetch="${prefix}"fetch
crypto="${prefix}"crypto
comm="${prefix}"comm

# Parameters
qtype=$1
msgid="${2%.del}"
dirid="${2}"

lockmagick="$3"
locktmout=30

# Directories
msgdir=${HOME}/persist/cables/${qtype}/"${msgid}"


error() {
    echo "loop (${msgid}): $1" 1>&2
    exit 1
}


# Sanity checks
[ ${#msgid} = 40 ] || error "bad msgid"


# .del actions: blocking lock (to let the renaming action finish)
if [ "${dirid}" != "${msgid}" ]; then
    if [ ${qtype} = queue ]; then

        if [ -e "${msgdir}".del ]; then
            exec flock -w ${locktmout} "${msgdir}".del/ "${comm}" ack "${msgid}"
        else
            error ".del directory not found"
        fi

    else

        if [ -e "${msgdir}".del ]; then
            exec flock -w ${locktmout} "${msgdir}".del/ "${comm}" fin "${msgid}"
        else
            error ".del directory not found"
        fi

    fi
else
    if [ ${qtype} = queue ]; then

        # non-blocking lock of combined operations
        if [ lockmagick != "${lockmagick}" ]; then
            exec flock -n "${msgdir}"/ "$0" ${qtype} "${msgid}" lockmagick
        fi

        "${validate}" ${qtype} "${msgid}"
        set +e

        if   [ -e "${msgdir}"/send.req ]; then
            "${fetch}"  send "${msgid}" && \
            "${crypto}" send "${msgid}" && \
            "${comm}"   send "${msgid}"
        elif [ -e "${msgdir}"/send.rdy ]; then
            "${crypto}" send "${msgid}" && \
            "${comm}"   send "${msgid}"
        elif [ -e "${msgdir}"/send.ok  ]; then
            if [ ! -e "${msgdir}"/ack.ok ]; then
                "${comm}" send "${msgid}"
            fi
        else
            error "send.req/rdy/ok not found"
        fi

        if   [ -e "${msgdir}"/ack.rdy ]; then
                 "${crypto}" ack  "${msgid}" && \
            exec "${comm}"   ack  "${msgid}"
        elif [ -e "${msgdir}"/ack.ok  ]; then
            exec "${comm}"   ack  "${msgid}"
        elif [ -e "${msgdir}"/ack.req ]; then
                 "${fetch}"  ack  "${msgid}" && \
                 "${crypto}" ack  "${msgid}" && \
            exec "${comm}"   ack  "${msgid}"
        fi

    else

        # non-blocking lock of combined operations
        if [ lockmagick != "${lockmagick}" ]; then
            exec flock -n "${msgdir}"/ "$0" ${qtype} "${msgid}" lockmagick
        fi

        "${validate}" ${qtype} "${msgid}"
        set +e

        if   [ -e "${msgdir}"/recv.req ]; then
                 "${fetch}"  recv "${msgid}" && \
                 "${crypto}" recv "${msgid}" && \
            exec "${comm}"   recv "${msgid}"
        elif [ -e "${msgdir}"/recv.rdy ]; then
                 "${crypto}" recv "${msgid}" && \
            exec "${comm}"   recv "${msgid}"
        elif [ -e "${msgdir}"/recv.ok  ]; then
            exec "${comm}"   recv "${msgid}"
        else
            error "recv.req/rdy/ok not found"
        fi

    fi
fi
